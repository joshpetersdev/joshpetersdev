 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../writing/writing.css">
  <title>Josh Peters - HTTP Server</title>
  <link rel="icon" type="image/png" href="../resources/favicon.png" />
  <script src="https://kit.fontawesome.com/77b1d2e451.js" crossorigin="anonymous"></script>
  <script defer src="../components/aside.js"></script>
  <script defer src="../components/footer.js"></script>
  <style>
     pre {
      color: #FDFDFF;
      padding: 1rem;
      border-radius: 8px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .highlight {
      color: #86D4DE;
      font-weight: bold;
    }
    .highlight.comment {
      color: #C6C5B9;
      font-style: italic;
    }
    .bash-code {
      color: #c5c8c6;
    }
    code {
      background-color: #2C2F31;
      padding: .25rem;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="body-container">
    <my-aside></my-aside>
    <main>
      <h1 class="desktop-header">JOSH PETERS</h1>
      <div class="content-container">
        <h2 class="article-title">HTTP Server in Golang</h2>
        <sub class="article-date">August 17, 2025</sub>
        <div class="text-body">
          
          <p><b>Introduction</b><br>In this article, I will walk you through how to create an HTTP server in Golang without using any third-party dependencies. We will utilize the <code>net/http</code> package, so be sure to import that. We will create a mock database by utilizing maps. We will be storing multiple users, so we need to create a <code>User</code> struct. It is important to note that when creating the User struct we need to include the JSON struct tag so that the attribute gets mapped to a valid JSON representation.</p>

          <pre class="go-code">
import (
  "net/http"
)

type User struct {
  Name string `json:"name"`
}

var userCache = make(map[int]User)
          </pre>

          <p><b>Create a ServeMux and Register Home Route</b><br>The first step is to create an <code>http.ServeMux</code>, which acts as an HTTP request multiplexer. It matches incoming request paths against registered patterns and dispatches them to the appropriate handler functions. After we create the mux, we register handler functions using <code>HandleFunc</code>, which associates a URL pattern with a function that has the signature <code>func(http.ResponseWriter, *http.Request)</code>.</p>

          <pre class="go-code">
func main() {
  mux := http.NewServeMux()
  mux.HandleFunc("/", handleRoot)

  http.ListenAndServe(":8080", mux)
}

func handleRoot(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintf(w, "Hello World")
}
          </pre>

          <p>The <code>http.ResponseWriter</code> is what your handler uses to send data back to the client. Whenever someone makes a request to your server, you use the ResponseWriter to write the response body, set headers, or define the HTTP status code. Think of it as your "response tool" for shaping what the client receives.</p>

          <p>The <code>*http.Request</code> represents the incoming request from the client. It holds all the details about what the client is asking for &#8212; such as the URL path, query parameters, headers, method(<code>GET</code>, <code>POST</code>, etc.), and even the request body if the client sent data.</p>

          <p style="margin-top: 3rem;"><b>POST Request</b><br>In Go's HTTP package, we can register handlers for specific routes and HTTP methods using <code>mux.HandleFunc</code>. By prefixing the route with <code>POST</code>, we are telling the multiplexer that this handler should only respond to requests sent with the <b>POST</b> method at the <code>/users</code> path.</p>

          <pre class="go-code">
func main() {
  // [...]
  mux.HandleFunc("POST /users", createUser)
  // [...]
}

func createUser(w http.ResponseWriter, r *http.Request) {
  var user User
  err := json.NewDecoder(r.Body).Decode(&user)
  if err != nil {
    http.Error(w, err.Error(), http.BadRequest)
    return
  }

  if user.Name == "" {
    http.Error(w, "name is required", http.BadRequest)
    return
  }

  userCache[len(userCache) + 1] = user

  w.WriteHeader(http.StatusNoContent)
}
          </pre>

          <p>When a request is made, the <code>createUser</code> handler function decodes the JSON body into a <code>User</code> struct. It checks that the <code>name</code> field is provided, saves the user in a cache, and responds with a <code>204 No Content</code> status if everything is valid.</p>

          <p style="margin-top: 3rem;"><b>Thread Safety</b><br>There is currently an issue with our program. Because we can access the user cache and write to it or read from it, this could create a race condition. To make it thread safe, we need to create a mutex. Above our <code>main</code> function, let's create this mutex:</p>

          <pre class="go-code">
var cacheMutex sync.RWMutex
          </pre>

          <p>What we just created is a read and write mutex. It blocks all the reading and writing when this mutex gets locked. A mutex, in general, is a safe way to synchronize your data in a multi-threaded application. Our web server is multi-threaded so it is necessary to have a mutex. Our mutex will block all incoming requests when it is locked. Now, inside the <code>createUser</code> function we will use our <code>RWMutex</code>:</p>

          <pre class="go-code">
func createUser(w http.ResponseWriter, r *http.Request) {
// [...]
  cacheMutex.Lock()
  userCache[len(userCache) + 1] = user
  cacheMutex.Unlock()
// [...]
}
          </pre>

          <p><b>GET Request</b><br>Going back to the <code>main</code> function, let's register a <code>GET</code> request right after our <code>POST</code> request.</p>

          <pre class="go-code">
func main() {
// [...]
  mux.HandleFunc("POST /users", createUser)
  mux.HandleFunc("GET /users/{id}", getUser)
// [...]
}
          </pre>

          <p>You'll notice that the <code>GET</code> request is similar to our <code>POST</code> request but has a path parameter added to it. The path parameter is the <code>{id}</code> and is user-defined. For example, if we request <code>/users/1</code> this will retrieve a user with an ID of 1.</p>

          <p>Next, let's implement the handler function for our GET request.</p>

          <pre class="go-code">
func getUser(w http.ResponseWriter, r *http.Request) {
  id, err := strconv.Atoi(r.PathValue("id"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    return
  }

  cacheMutex.RLock()
  user, ok := userCache[id]
  cacheMutex.RUnlock()
  if !ok {
    http.Error(w, "user not found", http.StatusNotFound)
    return
  }

  w.Header().Set("Content-Type", "application/json")
  j, err := json.Marshal(user)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    return
  }

  w.WriteHeader(http.StatusOK)
  w.Write(j)
}
          </pre>

          <p>In the above function, we retrieve the user by their ID by extracting the <code>id</code> from the request path and converting it to a number. If the conversion fails, it returns a <code>400 Bad Request</code>. To safely read from the shared <code>userCache</code>, it uses a read lock (<code>cacheMutex.RLock()</code>) and releases it afterward to prevent race conditions when multiple requests access the cache at the same time. Then it checks the cache for a matching user, and if no user is found, it responds with a <code>404 Not Found</code>. If the user exists, it converts the user struct to JSON, sets the response type to <code>application/json</code>, and sends the data back with a <code>200 OK</code> status. This ensures that clients can fetch user details in a clean and structured way.</p>

          <p style="margin-top: 3rem;"><b>DELETE Request</b><br>Let's implement a <code>DELETE</code> request to remove users from our mock database. We will again return to our <code>main</code> function and register the appropriate request. Similar to our <code>GET</code> request we need to add a path parameter to specify which user we want to delete.</p>

          <pre class="go-code">
func main() {
// [...]
  mux.HandleFunc("POST /users", createUser)
  mux.HandleFunc("GET /users/{id}", getUser)
  mux.HandleFunc("DELETE /user/{id}", deleteUser)
// [...]
}
          </pre>

          <p>Now, we need to define our <code>deleteUser</code> handler function:</p>

          <pre class="go-code">
func deleteUser(w http.ResponseWriter, r *http.Request) {
  id, err := strconv.Atoi(r.PathValue("id"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    return
  }

  if _, ok := userCache[id]; !ok {
    http.Error(w, "user not found", http.StatusBadRequest)
    return
  }
  
  cacheMutex.Lock()
  delete(userCache, id)
  cacheMutex.Unlock()

  w.WriteHeader(http.StatusNoContent)
}
          </pre>

          <p>Hopefully, you don't need much of an explanation by this point. As you can see, the above function is very similar to our <code>getUser</code> function so I won't go into detail about what this code is doing.</p>

          <p style="margin-top: 3rem;"><b>Testing</b><br>Lastly, let's test our server to make sure it is functioning as expected. Below are <code>curl</code> commands to test the <code>POST</code>, <code>GET</code>, and <code>DELETE</code> requests of our server:</p>

          <pre class="bash-code">
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "John"}' -v
          </pre>

          <p>You should get a <code>204 No Content</code> response.</p>

          <pre class="bash-code">
curl http://localhost:8080/users/1 -v
          </pre>

          <p>The response for this request should be <code>{"name": "John"}</code> with a status code of <code>200 OK</code>.</p>

          <pre class="bash-code">
curl -X DELETE http://localhost:8080/user/1 -v
          </pre>

          <p>After running our <code>DELETE</code> request, we should get a status code of <code>204 No Content</code>.</p>

          <p>Run the <code>GET</code> command again. You should get a <code>404 Not Found</code> status. This verifies that everything is working properly!</p>

          <p>We have finished writing our HTTP server. It is extremely simple and far from production ready. We could add additional features such as authentication or middleware but to implement these, it would make sense to use a third-party dependency. Since we are strictly using Go and it's standard libraries, we will call it good here.</p>
        </div>
      <my-footer>
        <i class="fa-solid fa-envelope" slot="email-logo"></i>
        <i class="fa-brands fa-github" slot="github-logo"></i> 
        <i class="fa-brands fa-linkedin" slot="linkedin-logo"></i>
      </my-footer>
    </main>
  </div>

  <script type="module">
    import { applyHighlights } from "../scripts/code-highlights.js";

    document.addEventListener("DOMContentLoaded", applyHighlights);
  </script>
</body>
</html>
