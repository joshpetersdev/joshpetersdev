<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../writing/writing.css">
  <title>Document</title>
  <script src="https://kit.fontawesome.com/77b1d2e451.js" crossorigin="anonymous"></script>
  <script defer src="../components/aside.js"></script>
  <script defer src="../components/footer.js"></script>
  <!-- <script defer src="writing/writing-script.js"></script> -->
</head>
<body>
  <div class="body-container">
    <my-aside></my-aside>
    <main>
      <h1 class="desktop-header">JOSH PETERS</h1>
      <div class="content-container">
        <h2>LRU Cache</h2>
        <p>This is the solution to the <a href="https://leetcode.com/problems/lru-cache/description/" class="leetcode-link">LRU Cache LeetCode</a> problem.</p>
        <div class="text-body">
          <p>Below, is a visual of an LRU cache. In this example, the LRU cache currently holds 3 elements and has reached its full capacity. The key-value pairs are ordered from the least recently used (left) to the most recently used (right):</p>
          <div class="ascii-container">
            <pre class="ascii-code">
capacity = 3 
┌─────────────────────────────────────┐
│ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
│ │ 1 │ 100 │ │ 2 │ 200 │ │ 4 │ 400 │ │
│ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
└─────────────────────────────────────┘
──────────────────────────────────────►
least recently            most recently
used                      used
            </pre>
          </div>

          <p>Let's insert a new key-value pair into the cache:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
                      capacity = 3 
                      ┌─────────────────────────────────────┐
    ┌───┬─────┐       │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
put │ 3 │ 300 │ ────► │ │ 1 │ 100 │ │ 2 │ 200 │ │ 4 │ 400 │ │
    └───┴─────┘       │ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
                      └─────────────────────────────────────┘
                      ──────────────────────────────────────►
            </pre>
          </div>

          <p>The new key-value pair added to the cache will become the most recent in the cache, therefore we should add it to the end of the cache. Since the cache is at maximum capacity, we must remove the least recently used pair. After the least recently used pair has been evicted and the new pair added, the cache will look like this:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
┌─────────────────────────────────────┐
│ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
│ │ 2 │ 200 │ │ 4 │ 400 │ │ 3 │ 300 │ │
│ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
└─────────────────────────────────────┘
──────────────────────────────────────►
            </pre>
          </div>

          <p>
            We need to implement the <code>put</code> operation. It can be summarized with the following steps:
            <ol>
              <li>Remove the least recently used key-value pair from the cache.</li>
              <li>Add the new key-value pair to the most recently used end of the cache.</li>
            </ol>
          </p>

          <p>We also need to write the <code>get</code> operation. The key-value pair we retrieve will become the most recently used pair:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
                    move to most recently used end
                    ┌──────────────────────────────┐
                    │                              │
             ┌──────│──────────────────────────────│─┐
             │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │ │
get(2) ────► │ │ 2 │ 200 │ │ 4 │ 400 │ │ 3 │ 300 │ ▼ │
             │ └───┴─────┘ └───┴─────┘ └───┴─────┘   │
             └───────────────────────────────────────┘
             ────────────────────────────────────────►

             ┌─────────────────────────────────────┐
             │ ┌───┬─────┐ ┌───┬─────┐ ┌───┬─────┐ │
             │ │ 4 │ 400 │ │ 3 │ 300 │ │ 2 │ 200 │ │ ────► return 200
             │ └───┴─────┘ └───┴─────┘ └───┴─────┘ │
             └─────────────────────────────────────┘
             ──────────────────────────────────────►
            </pre>
          </div>

          <p>
            The <code>get</code> operation can be summarized with the following steps:
            <ol>
              <li>Move the key-value pair that is being retrieved to the most recently used end of the cache.</li>
              <li>Return the value of the key-value pair.</li>
            </ol>
          </p>

          <p>
            To perform the <code>put</code> and <code>get</code> operations, we need to add or remove elements efficiently. The linked list is the best data structure for accomplishing this. Now, should we use a singly linked list or a doubly linked list? Regardless of which one we choose, the time complexity of adding or removing pairs from the head of the list will be <i>O(1)</i>. However, if we need to add or remove a pair from the tail of the list then utilizing a singly linked list will result in a time complexity of <i>O(n)</i> because we will have to traverse the entire list to reach the tail. This is why we will select to use the doubly linked list. Utlizing the doubly linked list will allow us to add or remove a pair from the tail of the list with a time complexity of <i>O(1)</i>.
          </p>

          <p>We will need to create a <code>head</code> and <code>tail</code> node that will allow us to add and remove nodes from the ends of the cache.</p>

          <div class="ascii-container">
            <pre class="ascii-code">
<!-- capacity = 3  -->
<!-- ┌────────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌────────┐ -->
<!-- │  head  │      │ 4 │ 400 │      │ 3 │ 300 │      │ 2 │ 200 │      │  tail  │ -->
<!-- └────────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └────────┘ -->
            </pre>
          </div>

          <p>Performing operations on nodes at the ends of the cache is quick and easy but to perform operations on the nodes in the middle would require use to traverse the linked list until we reach the desired node. To access nodes at any location in the linked list in <i>O(1)</i> time we can use a hashmap to store the pre-existing key-value pairs. This allows us to access a node by its key in constant time.</p>

          <div class="ascii-container">
            <pre class="ascii-code">
<!-- ┌────────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌────────┐ -->
<!-- │  head  │      │ 4 │ 400 │      │ 3 │ 300 │      │ 2 │ 200 │      │  tail  │ -->
<!-- └────────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └────────┘ -->
                    <!-- ▲                ▲                ▲   -->
                    <!-- │                │                │ -->
                    <!-- └─────┐          └────────┐       └───────────┐ -->
                          <!-- │                   │                   │ -->
<!-- hashmap: {(key: 4, value: •), (key: 3, value: •), (key: 2, value: •)} -->
            </pre>
          </div>

          <p>Below is a visual to understand the logic used to add a new key-value pair to the cache:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
          <!-- ┌──────────────────────────────────────────┐ -->
          <!-- │ Does the key already exist in the cache? │ -->
          <!-- │ Verify by querying the hash map.         │ -->
          <!-- └──────────────────────────────────────────┘ -->
              <!-- ┌────── Yes ──────┴───── No ───────┐ -->
              <!-- │                                  │ -->
              <!-- ▼                                  ▼ -->
<!-- ┌─────────────────────────────┐     ┌─────────────────────────┐ -->
<!-- │ Remove this key's node from │     │ Would adding a new node │ -->
<!-- │ the linked list.            │     │ exceed capacity?        │ -->
<!-- └─────────────────────────────┘     └─────────────────────────┘ -->
              <!-- └──────┐   ┌───────── No ────────┴─ Yes ──┐ -->
                     <!-- │   │                              │ -->
                     <!-- │   │                              ▼ -->
                     <!-- │   │          ┌─────────────────────────────────────┐  -->
                     <!-- │   │          │ 1. Remove the least recently used   │ -->
                     <!-- │   │   ┌──────│    node from the linked list.       │ -->
                     <!-- │   │   │      │ 2. Remove it from the hash map too. │ -->
                     <!-- │   │   │      └─────────────────────────────────────┘ -->
                     <!-- │   │   │ -->
                     <!-- │   │   │ -->
                     <!-- ▼   ▼   ▼ -->
      <!-- ┌──────────────────────────────────────┐ -->
      <!-- │ 1. Add the node as the most recently │ -->
      <!-- │    used node of the linked list.     │ -->
      <!-- │ 2. Add it to the hash map too.       │ -->
      <!-- └──────────────────────────────────────┘ -->
            </pre>
          </div>

          <p>Below is the process for retrieving a key's value from the cache:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
                  <!-- ┌──────────────────────────────────────────┐ -->
                  <!-- │ Does the key already exist in the cache? │ -->
                  <!-- │ Verify by querying the hash map.         │ -->
                  <!-- └──────────────────────────────────────────┘ -->
                      <!-- ┌──── Yes ──────┴────── No ─────┐ -->
                      <!-- │                               │ -->
                      <!-- ▼                               ▼ -->
<!-- ┌─────────────────────────────────────────────┐  ┌───────────┐ -->
<!-- │ Make the node at this key the most recently │  │ Return -1 │ -->
<!-- │ used through the following steps:           │  └───────────┘ -->
<!-- │                                             │ -->
<!-- │ 1. Remove the node.                         │ -->
<!-- │ 2. Add the node as the most recently used   │ -->
<!-- │    node of the linked list.                 │ -->
<!-- └─────────────────────────────────────────────┘ -->
                      <!-- │ -->
                      <!-- ▼ -->
<!-- ┌─────────────────────────────────────────────┐ -->
<!-- │ Return the value associated with this node. │ -->
<!-- └─────────────────────────────────────────────┘  -->
            </pre>
          </div>

          <p>Let's now begin to explore the process of implementing the helper functions &#8212; <code>addToTail</code> and <code>removeNode</code>.</p>

          <p>We will start with <code class="language-bash">addToTail</code>. Below is a visual that explains the process of adding a node to the cache:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
                                        <!-- ┌───┬─────┐ -->
                              <!-- addToTail │ 3 │ 300 │ -->
                                        <!-- └───┴─────┘ -->
                                             <!-- │ -->
                                             <!-- ▼ -->
<!-- ┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌──────┐ -->
<!-- │ head │      │ 2 │ 200 │      │ 4 │ 400 │      │ tail │ -->
<!-- └──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └──────┘ -->
                               <!-- prevNode -->

                                        <!-- ┌───┬─────┐ -->
                                     <!-- ┌──┤ 3 │ 300 ├─┐ -->
                                     <!-- │  └───┴─────┘ │ -->
                                     <!-- │    ▲    ▲    │ -->
                                     <!-- ▼    │    │    ▼ -->
<!-- ┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐│    │┌──────┐ -->
<!-- │ head │      │ 2 │ 200 │      │ 4 │ 400 ├┘    └┤ tail │ -->
<!-- └──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘      └──────┘ -->
                               <!-- prevNode -->
            </pre>
          </div>

          <p>Below is a visual for the process of removing a node using the <code>removeNode</code> helper function:</p>

          <div class="ascii-container">
            <pre class="ascii-code">
                                <!-- ┌───┬─────┐ -->
                     <!-- removeNode │ 4 │ 400 │ -->
                                <!-- └───┴─────┘ -->
                                    <!-- │ -->
                                    <!-- ▼ -->
<!-- ┌──────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌───┬─────┐ ───► ┌──────┐ -->
<!-- │ head │      │ 2 │ 200 │      │ 4 │ 400 │      │ 3 │ 300 │      │ tail │ -->
<!-- └──────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └───┴─────┘ ◄─── └──────┘ -->


                    <!-- ┌────────────────────────────────┐ -->
                    <!-- │                                ▼ -->
<!-- ┌──────┐ ───► ┌───┬─┴───┐ ---► ┌---------┐ ---► ┌───┬─────┐ ───► ┌──────┐ -->
<!-- │ head │      │ 2 │ 200 │      | 4 │ 400 |      │ 3 │ 300 │      │ tail │ -->
<!-- └──────┘ ◄─── └───┴─────┘ ◄--- └---------┘ ◄--- └───┴┬────┘ ◄─── └──────┘ -->
                   <!-- ▲                                 │ -->
                   <!-- └─────────────────────────────────┘ -->
            </pre>
          </div>

          <p>Lastly, let's take a look at the time and space complexity. Both helper functions have a time complexity of <i>O(1)</i>. The <code>put</code> and <code>get</code> functions both use the helper functions. Therefore, <i>O(1)</i> is the time complexity. The overall space complexity is <i>O(n)</i> where <i>n</i> is the capacity size of the cache.</p>
        </div>
      </div>
      <my-footer>
        <i class="fa-solid fa-envelope" slot="email-logo"></i>
        <i class="fa-brands fa-github" slot="github-logo"></i>
        <i class="fa-brands fa-linkedin" slot="linkedin-logo"></i>
      </my-footer>
    </main>
    <div class="date-aside">
      August 15, 2025
    </div>
  </div>
</body>
</html>
